//This part represents the blockchain, file name index.js to search easily by node

const Block = require('./block.js');
const fs = require('fs');

const EthCrypto = require('eth-crypto');
const cryptoJSON = require('crypto-json');

async function call(transaction, key){
  const encryptedObject = EthCrypto.cipher.parse(transaction.encryptedString);
  const message = await EthCrypto.decryptWithPrivateKey(
       key, // privateKey
       encryptedObject // encrypted-data
   );

   const algorithm = 'camellia-128-cbc'
   const encoding = 'hex'
   const password = message;
   const keys = ['amount', 'address']
   const data = cryptoJSON.decrypt(transaction.output, password, {encoding, keys, algorithm});
   return data;
}


class Blockchain{
  constructor(){
    this.chain = Block.getBlocks();                       //This initialises an array with initial block as genesis block generated by calling genesis function in block class as a static one.
  }

  addBlock(data){
    const lastBlock = this.chain[this.chain.length-1];      //Data represents the blockchain passed while callig this function and "this" represents the passed blockchain or data.
    const block = Block.mineBlock(lastBlock, data);
    this.chain.push(block);  //Adds block to curret blockchain
    fs.readFile('test.json', function (err, data) {
    var json = JSON.parse(data)
    json.push(block)
    fs.writeFileSync("test.json", JSON.stringify(json))
    })
    return block;   //returns newly mined block;
  }

  isValid(chain){
    if(JSON.stringify(chain[0]) !== JSON.stringify(Block.genesis())) return false;  // retur false when genesis block != 1st block;
    for(let i = 1; i < chain.length; i++){
      const block = chain[i];
      const lastBlock = chain[i-1];

      if(block.lastHash !== lastBlock.hash  || block.hash !== Block.blockHash(block)){   // compare hashes
        return false; //BlockHash function in block.js and it is used to check if present hash is valid or not
      }
    }

    return true; //if everything correct return true;
  }

  replaceChain(newChain){                                                       //If current chain is not longest than replace it with longest
    if(newChain.length <= this.chain.length){                                   //Check passed chain is longer than given vhain or not?
      console.log("This is not the longest chain so can't replaced ");
      return;
    }else if(!this.isValid(newChain)){  // check validity of newChain in case it is longer than given chain
      console.log("Chain is not valid");
      return
    }
    fs.writeFileSync("test.json", JSON.stringify(newChain));
    console.log('Replacing Chain');
    this.chain = newChain;              //All confirms and conditions done than replace chain
  }

  async getUserData(address, privateKey){
    let transactions = [];

    this.chain.forEach(block => block.data.forEach(transaction => {
      transactions.push(transaction);
    }));
    const outputFinal = [];
    transactions.forEach(transaction => {
              const valuess = JSON.stringify(transaction.outputs);
              // console.log("valuess :", transaction.outputs[1]);
              if(valuess.substring(1, 2) === '{'){
                if(transaction.outputs[1].address === address){
                  outputFinal.push(transaction.outputs);
                };
              }else{
                transaction.outputs.forEach(output => {
                  if(output[1].address === address){
                      outputFinal.push(output);
                  };
                })
              }


    })
    if(outputFinal.length){
      for(var i = 0 ; i <outputFinal.length; i++){
          var mydata = await call(outputFinal[i][0], privateKey);
          outputFinal[i] = mydata;
      }
    }
    const final = {'Received Data ': outputFinal};
    return final
  }


}

module.exports = Blockchain;
